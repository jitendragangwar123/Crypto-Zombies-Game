/* 
Ganache:-
:-You can do so by using a tool called Ganache, which sets up a local Ethereum network.
:-Every time Ganache starts, it creates 10 test accounts and gives them 100 Ethers to make testing easier. 
Since Ganache and Truffle are tightly integrated
*/

/* Writting the test cases for below function:-

    function createRandomZombie(string _name) public {
       require(ownerZombieCount[msg.sender] == 0);
       uint randDna = _generateRandomDna(_name);
       randDna = randDna - randDna % 100;
       _createZombie(_name, randDna);
     }
 */

/*
Usually, every test has the following phases:-
1.set up:- 
    In which we define the initial state and initialize the inputs.
2.act:- 
    where we actually test the code. Always make sure you test only one thing.
3.assert:-
    where we check the results.
*/

/*
Logs and Events:-
:- Once we specified the contract we wanted to test using artifacts.require, Truffle
    automatically provides the logs generated by our smart contract.
    
:- result.tx: the transaction hash
:- result.receipt: an object containing the transaction receipt.     
*/

/*
Hooks:- 
    :-In just a few minutesðŸ¤ž, we'll have more than one test and the way this works is that 
    each test should start with a clean sheet. Thus, for every single test we'll have to create a new instance of our smart contract.
    :-One of Mocha's (and Truffle's) features is the ability to have some snippets of code called hooks run before or after a test. 
    :-To run something before a test gets executed, the code should be put inside a function named beforeEach().
    
            beforeEach(async () => {
              // let's put here the code that creates a new contract instance
            });
            
    :-similar to the beforeEach() function explained above, we'll make a function called afterEach():

            afterEach(async () => {
                   await contractInstance.kill();
                });            
*/            

const CryptoZombies = artifacts.require("CryptoZombies");
const zombieNames = ["Zombie 1", "Zombie 2"];
contract("CryptoZombies", (accounts) => {
    let [alice, bob] = accounts;
    //by using hooks
    let contractInstance;
    beforeEach(async() =>{
        contractInstance = await CryptoZombies.new();
    });
    
    it("should be able to create a new zombie", async () => {
        //Can use the contract abstraction to initialize our instance like this:-
       // const contractInstance = await CryptoZombies.new();
        //msg.sender is set to Alice's address
        const result=await contractInstance.createRandomZombie(zombieNames[0], {from: alice});
        //If result.receipt.status is equal to true it means that the transaction was successful
        assert.equal(result.receipt.status,true);
        //Retrieve the name of Alice's newly created zombie 
        assert.equal(result.logs[0].args.name,zombieNames[0]);
    })
    it("should not allow two zombies",async() => {

    })
})


